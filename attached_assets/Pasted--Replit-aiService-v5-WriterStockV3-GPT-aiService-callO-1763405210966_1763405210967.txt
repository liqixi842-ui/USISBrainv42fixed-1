👉 把下面这段发给 Replit（只针对 aiService，别改别的）
现在 v5 WriterStockV3 的所有 GPT 调用都失败，日志显示：

  ❌ [aiService] callOpenAI failed: provider.call is not a function

说明 aiService.js 中的 callOpenAI 写法不符合 getMultiAIProvider 的实际返回类型。

请按以下步骤排查并修复（只改 aiService.js，不要改其它逻辑）：

【1】打印 getMultiAIProvider 的类型和结构

在 v3_dev/services/aiService.js 里的 callOpenAI 函数中，临时加入调试：

```js
const provider = getMultiAIProvider();
console.log('[AI_SERVICE_DEBUG] typeof provider =', typeof provider);
if (provider && typeof provider === 'object') {
  console.log('[AI_SERVICE_DEBUG] provider keys =', Object.keys(provider));
}


然后调用一次 buildResearchReportV5('NVDA','equity')，把这两行 debug 输出贴出来。

【2】根据返回类型调整调用方式

如果 typeof provider === 'function'：
表示 getMultiAIProvider 返回的是一个函数，应当这样调用：

const result = await provider({
  model: options.model || 'gpt-4o',
  messages: [
    { role: 'system', content: options.systemPrompt || 'You are a helpful financial analyst.' },
    { role: 'user', content: options.prompt }
  ],
});
const content = result.content || result.choices?.[0]?.message?.content || '';
return content;


如果 typeof provider === 'object'，检查它有哪些方法：

若有 provider.call，才用 await provider.call(payload)；

若只有 provider.chat，则用 await provider.chat(payload)；

若是 OpenAI 官方 SDK 风格（provider.chat.completions.create），则改成：

const completion = await provider.chat.completions.create({
  model: options.model || 'gpt-4o',
  messages: [
    { role: 'system', content: options.systemPrompt || 'You are a helpful financial analyst.' },
    { role: 'user', content: options.prompt }
  ]
});
return completion.choices[0].message.content;


【3】保证 callOpenAI 的返回值始终是 string

在 aiService.js 里，callOpenAI 最后要保证：

if (typeof text !== 'string') {
  text = JSON.stringify(text);
}
return text.trim();


【4】验证 WriterStockV3 不再报错

重新运行一次：

node -e "const { buildResearchReportV5 } = require('./v3_dev/services/reportService'); (async () => {
  const r = await buildResearchReportV5('NVDA', 'equity');
  console.log('[TEST] thesis_enhanced length:', r.thesis_enhanced?.length || 0);
  console.log('[TEST] overview_enhanced length:', r.overview_enhanced?.length || 0);
  console.log('[TEST] industry_enhanced length:', r.industry_enhanced?.length || 0);
})();


预期结果：

不再出现 "provider.call is not a function"

thesis_enhanced / overview_enhanced / valuation_enhanced / industry_enhanced 的长度大幅增加（> 500 字）

【5】确认 PDF 使用的是这些长文字段

最后再生成一次 /v3/report/NVDA?format=pdf 和 ?format=json：

JSON 里 thesis_enhanced 至少 800 字左右；

PDF 第 3/4/5/6 页的文字明显变长，不再只是几句 stub；

Key Catalysts / Key Risks 仍然是 8 条长句，没有 "Additional factor"。


---

你把这段发给 Replit，让它自己查 aiService 里的 `provider` 是什么，然后改对。

等它回你“`provider` 调用已经修好、thesis_enhanced 长度变成 xxx 字”，  
你就再发一份新的 PDF 来验证文案质量，我们再看要不要做微调（比如改语气句式）。

这次不会再是“修了没变”，因为我们已经证明：  
- 修 RiskCleaner → PDF 立刻没了 Additional factor  
- 修 const / type → 500 立刻消失  

接下来就是 **最后这块：让 Writer 真正写出长文，而不是 fallback 那几句**。
::contentReference[oaicite:4]{index=4}