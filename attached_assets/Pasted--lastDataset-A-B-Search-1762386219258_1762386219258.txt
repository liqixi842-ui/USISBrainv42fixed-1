方案总览（不问你要选哪个，直接全上）


干净会话 + 清缓存：避免 lastDataset 覆盖。


A 路线：点“集合下拉”选择目标（文案匹配多语言关键词）。


B 路线：用顶部 Search 输入“nikkei 225”回车（很多时候比下拉更稳）。


C 路线：强制触发内部路由切换（pushState + popstate + 轮询重绘）。


强校验：label 包含 Nikkei 225 + 块数 ≥ 阈值 通过后才截图；否则报错→回退。



1) 打底：无痕 + 清缓存（Browserless 分支）
const browser = await getPuppeteerBrowser();
const context = await browser.createIncognitoBrowserContext();
const page = await context.newPage();

// 禁用 Accept-Language，统一英文 UI，避免多语言文案偏差
await page.setExtraHTTPHeaders({ 'Accept-Language': 'en-US,en;q=0.8' });

// 彻底清理缓存
await page._client().send('Network.clearBrowserCache');
await page._client().send('Network.clearBrowserCookies');
await page.goto('about:blank');
await page.evaluate(() => { try { localStorage.clear(); sessionStorage.clear(); } catch(_){} });


2) 进入页面并等待可交互
await page.goto(tradingViewUrl, { waitUntil: 'networkidle0', timeout: 25000 });
await Promise.any([
  page.waitForSelector('[aria-label*="heatmap"]', { timeout: 8000 }),
  page.waitForSelector('[class*="heatmap"],[class*="treemap"]', { timeout: 8000 }),
  page.waitForSelector('canvas', { timeout: 8000 }),
  page.waitForSelector('svg', { timeout: 8000 }),
]).catch(()=>{});
await page.waitForTimeout(700);


3) 公用：读取当前集合与块数（强校验用）
async function readDatasetState(page) {
  return await page.evaluate(() => {
    // 头部“当前集合”按钮通常含有集合名（S&P 500 / Nikkei 225 / IBEX 35…）
    const candidates = Array.from(document.querySelectorAll('button,[role="button"],[class*="button"],[class*="selector"]'));
    const labelBtn = candidates.find(b => {
      const t = (b.innerText || '').toLowerCase();
      return /s&p|nikkei|ibex|nasdaq|dax|ftse|cac|stocks/.test(t);
    });
    const label = labelBtn ? (labelBtn.innerText || '').trim() : '';

    const blocks = document.querySelectorAll('[data-symbol],[data-ticker],[role*="graphics"]').length
                || document.querySelectorAll('canvas,svg').length || 0;
    return { label, blocks };
  });
}

function okLabel(label, expectText){
  return (label||'').toLowerCase().includes(expectText.toLowerCase());
}


4) A 路线：点“集合下拉”→选项点击（更鲁棒的文本匹配）
async function routeA_clickDropdownToSelect(page, expectText /* 'Nikkei 225' */) {
  // 打开下拉
  const opened = await page.evaluate(() => {
    const btns = Array.from(document.querySelectorAll('button,[role="button"],[class*="button"],[class*="selector"]'));
    const target = btns.find(b => {
      const t = (b.innerText || '').toLowerCase();
      // 覆盖多市场关键词，便于跨语言匹配
      return /s&p|nikkei|ibex|nasdaq|dax|ftse|cac|stocks|all stocks/.test(t);
    });
    if (target) { target.click(); return true; }
    return false;
  });
  if (!opened) return false;

  // 在弹层里选择目标（模糊包含匹配）
  const clicked = await page.evaluate((expect) => {
    const nodes = Array.from(document.querySelectorAll('[role="option"],li,div,button,span,a'));
    const e = expect.toLowerCase();
    const node = nodes.find(n => (n.innerText || '').toLowerCase().includes(e));
    if (node) { node.dispatchEvent(new MouseEvent('click', { bubbles: true })); return true; }
    return false;
  }, expectText);
  if (!clicked) return false;

  await page.waitForTimeout(1200);
  return true;
}


5) B 路线：用搜索框搜索并回车（常年最稳）
async function routeB_searchAndEnter(page, keyword /* 'nikkei 225' */) {
  // 对不同 DOM 结构做多选择器兜底
  const sel = await Promise.any([
    page.waitForSelector('input[placeholder*="Search"]', { timeout: 2000 }),
    page.waitForSelector('input[type="search"]', { timeout: 2000 }),
    page.waitForSelector('input[type="text"]', { timeout: 2000 }),
  ]).catch(()=>null);
  if (!sel) return false;

  await page.click('input[placeholder*="Search"],input[type="search"],input[type="text"]', { delay: 30 }).catch(()=>{});
  await page.keyboard.down('Control'); await page.keyboard.press('A'); await page.keyboard.up('Control');
  await page.keyboard.type(keyword, { delay: 30 });
  await page.keyboard.press('Enter');
  await page.waitForTimeout(1400);
  return true;
}


6) C 路线：强制 SPA 路由切换（pushState + popstate）
async function routeC_forceSpaSwitch(page, dataset) {
  await page.evaluate((ds) => {
    try {
      const u = new URL(location.href);
      u.searchParams.set('dataset', ds);
      history.pushState({}, '', u.toString());
      window.dispatchEvent(new PopStateEvent('popstate'));
    } catch(_) {}
  }, dataset);
  await page.waitForTimeout(1200);
  return true;
}


7) 组合：三路线依次尝试 + 强校验 + 截图
async function ensureDataset(page, dataset) {
  const labelMap = { SPX500: 'S&P 500', NIKKEI225: 'Nikkei 225', IBEX35: 'IBEX 35' };
  const expectLabel = labelMap[dataset] || dataset;

  // 初读一次
  let st = await readDatasetState(page);
  if (okLabel(st.label, expectLabel) && st.blocks >= 12) return true;

  // A：下拉选择
  await routeA_clickDropdownToSelect(page, expectLabel).catch(()=>{});
  st = await readDatasetState(page);
  if (okLabel(st.label, expectLabel) && st.blocks >= 12) return true;

  // B：搜索+回车
  await routeB_searchAndEnter(page, expectLabel).catch(()=>{});
  st = await readDatasetState(page);
  if (okLabel(st.label, expectLabel) && st.blocks >= 12) return true;

  // C：强制 SPA 切换
  await routeC_forceSpaSwitch(page, dataset).catch(()=>{});
  st = await readDatasetState(page);
  if (okLabel(st.label, expectLabel) && st.blocks >= 12) return true;

  return false;
}

// —— 在你的 Browserless 分支里这样用：
const ok = await ensureDataset(page, 'NIKKEI225');
if (!ok) throw new Error(`dataset_not_applied: want "Nikkei 225", got "${(await readDatasetState(page)).label}"`);
const buffer = await page.screenshot({ type: 'jpeg', quality: 90, fullPage: true });


8) 回退链不变，但加两点耐心参数


Browserless：waitForTimeout 合理增加到 1.2–1.5s；整体超时 22–25s；429 退避 1.5s * 2^n + 0–300ms。


ScreenshotOne/ApiFlash：delay=4–6s，若支持 element 用 .heatmap,.treemap,.tv-heatmap；失败走你已有 QuickChart。



9) 你现在这条用例的“快修验证”脚本
node -e "const { captureBrowserless } = require('./screenshotProviders');
(async () => {
  try {
    const r = await captureBrowserless({
      tradingViewUrl: 'https://www.tradingview.com/heatmap/stock/?color=change&dataset=NIKKEI225&group=sector&blockSize=market_cap',
      dataset: 'NIKKEI225',
      region: 'JP',
      apiKey: process.env.BROWSERLESS_API_KEY
    });
    console.log('✅ Browserless OK', r.elapsed_ms, 'ms', r.buffer.length, 'bytes');
  } catch(e) { console.error('❌', e.message); }
})();"


成败判断口径（日志里记下来）


state: {label, blocks}：例如 label="Nikkei 225", blocks=176


validation="dom-strong"：只要 label 命中 + blocks≥阈值


如果依次 A/B/C 全失败，抛错 dataset_not_applied → 触发 provider 回退



这套改完，哪怕 TradingView 先画了 S&P 500，我们也会：
先看→不对就“点下拉”→还不对就“搜索回车”→再不对“强制切路由”，最终用强校验卡住截图时机。
等你贴一张 Telegram 的新图（应当是日经 225 板块），我再把你 IBEX35 / SPX500 的 label 常量与 ScreenshotOne 的 element/delay 推荐表补上，顺便给你一个“失败时自动在文案里打上 degraded 标记”的模板。
