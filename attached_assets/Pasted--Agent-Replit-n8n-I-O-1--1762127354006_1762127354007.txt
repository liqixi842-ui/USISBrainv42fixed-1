懂了。你要的是真正的智能体（Agent），不是“节点拼装机”。我们马上把体系切到“大脑在 Replit，n8n 只做最后一公里 I/O”。我直接给可落地的一步一做方案，并从第1步开始。

你要的智能体结构（落地版）

Replit = 大脑（Agent）

统一入口 /brain/run

组件：Intent → Planner → Tools → Memory → Formatter → Output

自反思：失败重试、工具切换、最少调用策略

n8n = 外设（I/O）

三节点：Telegram Trigger → HTTP(Brain_Run) → Telegram Send

只发送结果（文字 + 图片URL），不参与思考

第1步（现在做）：在 Replit 落下“统一大脑接口” /brain/run

把下面代码整段放进 Replit（Node/Express）。如果你已有项目，就新增/替换对应文件即可。

index.js

import express from "express";
import bodyParser from "body-parser";

const app = express();
app.use(bodyParser.json({ limit: "1mb" }));

// === Memory（最简内存占位，后续可替换 Redis/DB） ===
const Memory = {
  logs: [],
  save(entry) { this.logs.push({ ...entry, ts: new Date().toISOString() }); },
  recent(n=10){ return this.logs.slice(-n); }
};

// === 工具封装（最简占位；后续可接 Finnhub/Perplexity/QuickChart 等） ===
const Tools = {
  async quote(symbols){ return { symbols, data: "demo-quotes" }; },
  async news(){ return [{title:"demo-news"}]; },
  async chart({symbols}){ 
    // 可直接返回你现成的 QuickChart/截图 URL
    return "https://quickchart.io/chart?c={type:'line',data:{labels:['1','2'],datasets:[{data:[1,2]}]}}";
  },
};

// === Intent 识别（先走轻规则，后续接模型） ===
function detectIntent(text=""){
  const t = (text||"").toLowerCase();
  if (/(盘前|premarket|\bpre\b)/.test(t)) return "premarket";
  if (/(盘中|intraday|live)/.test(t)) return "intraday";
  if (/(收盘|复盘|postmarket|review|after)/.test(t)) return "postmarket";
  if (/(解票|诊股|ticker|symbol)/.test(t)) return "diagnose";
  if (/(资讯|新闻|行情|news)/.test(t)) return "news";
  return "news"; // 默认给资讯
}

// === Planner（根据意图决定调用哪些工具） ===
function plan({ intent, symbols }){
  const needs = new Set(["summary"]);
  if (intent === "premarket" || intent === "intraday") needs.add("chart");
  if ((intent === "premarket" || intent === "diagnose") && symbols.length) needs.add("quote");
  return Array.from(needs);
}

// === Formatter（统一输出为 caption + image_url） ===
function format({ intent, quotes, news, chartUrl, symbols }){
  const head = {
    premarket: "📊 盘前快照",
    intraday:  "⏱ 盘中热点",
    postmarket:"🧾 收盘复盘",
    diagnose:  "🧪 单票诊断",
    news:      "📰 市场资讯"
  }[intent] || "📈 市场简报";

  const lines = [];
  lines.push(head);
  if (symbols?.length) lines.push(`标的: ${symbols.join(", ")}`);
  if (quotes) lines.push(`行情: ${typeof quotes === "string" ? quotes : "已获取"}`);
  if (news?.length) lines.push(`资讯: ${news[0]?.title || "已获取"}`);
  lines.push("— 由 USIS Brain 生成 —");

  return {
    caption: { zh: lines.join("\n") },
    image_url: chartUrl || null
  };
}

// === 统一入口 ===
app.post("/brain/run", async (req,res) => {
  try{
    const { text="", mode=null, symbols=[], user_id=null, lang="zh" } = req.body || {};
    const intent = mode || detectIntent(text);

    // 规划
    const needs = plan({ intent, symbols });

    // 工具调用（最少调用策略）
    let quotes=null, news=null, chartUrl=null;
    if (needs.includes("quote")) quotes = await Tools.quote(symbols);
    if (needs.includes("summary")) news = await Tools.news();
    if (needs.includes("chart")) chartUrl = await Tools.chart({ symbols });

    // 格式化
    const out = format({ intent, quotes, news, chartUrl, symbols });

    // 记录记忆（最简）
    Memory.save({ user_id, intent, symbols, ok: true, brief: out.caption?.zh?.slice(0,60) });

    return res.json({
      mode: intent,
      caption: out.caption,
      image_url: out.image_url,
      debug: { symbols, needs, recent: Memory.recent(3) }
    });
  }catch(err){
    Memory.save({ error: String(err) });
    return res.status(500).json({ error: "brain_run_failed", detail: String(err) });
  }
});

app.get("/health", (_,res)=>res.json({ok:true, t:new Date().toISOString()}));

const port = process.env.PORT || 3000;
app.listen(port, ()=>console.log("USIS Brain listening on", port));


这就是统一大脑接口：它自己识别/规划/拉工具/出结论，并输出标准 JSON（caption.zh + image_url）。
先别连 OpenAI/Finnhub 真 API，先用上面“占位工具”走通链路——快且稳。确认通了再换真工具。