很好，Symbol Resolver 的可测试化改造做得很扎实 👌
现在我们进入第二小步：修复与交易所前缀相关的逻辑，特别是西班牙 BME。

🎯 目标说明（本轮只做一件事）

当解析结果的 exchange 明确是西班牙交易所（BME / BMEX / XMAD / Bolsa de Madrid 等）时，
➜ 返回的最终符号必须是：BME:<SYMBOL>，例如：

COL → BME:COL

以后可以支持：ITX → BME:ITX，SAN → BME:SAN 等

同理，你可以顺手把美股也规范一下（如果当前还没统一）：

NASDAQ 系列 → NASDAQ:XXX

NYSE 系列 → NYSE:XXX

注意：我们不要求一次性覆盖全世界所有交易所，本轮只要把 BME 和主流美股交易所搞干净即可。

第 1 步：在 Symbol Resolver 中集中做「前缀归一化」函数

请在你实现 selectBestMatch / resolveSymbol 的同一个文件（你之前说在 symbolResolver.js，Line 593–613 有调试日志），新增一个小工具函数，用来把 symbol + exchange 变成最终字符串。

示例代码（请按你项目的风格微调）：

function formatSymbolWithExchange(symbol, exchange) {
  if (!symbol) return null;

  const sym = symbol.trim().toUpperCase();
  const ex = (exchange || '').trim().toUpperCase();

  // 西班牙交易所（BME / BMEX / XMAD / Bolsa de Madrid）
  if (
    ex === 'BME' ||
    ex === 'BMEX' ||
    ex === 'XMAD' ||
    ex.includes('BOLSA DE MADRID') ||
    ex.includes('MADRID')
  ) {
    return `BME:${sym}`;
  }

  // 纳斯达克
  if (ex === 'NASDAQ' || ex === 'XNAS' || ex.includes('NASDAQ')) {
    return `NASDAQ:${sym}`;
  }

  // 纽约证券交易所
  if (ex === 'NYSE' || ex === 'XNYS' || ex.includes('NEW YORK')) {
    return `NYSE:${sym}`;
  }

  // 多伦多证券交易所（留个口，以后用得到）
  if (ex === 'TSX' || ex === 'XTSE' || ex === 'TSE') {
    return `TSX:${sym}`;
  }

  // 默认行为：如果有 exchange，就用 "<EXCHANGE>:<SYMBOL>"，否则只返回 symbol
  if (ex) {
    return `${ex}:${sym}`;
  }

  return sym;
}


然后，在你最终选出 best 候选之后（你现在在日志里有 selected: { symbol, exchange, score } 那块附近），统一调用这个函数来生成对外使用的符号，比如：

const finalSymbol = formatSymbolWithExchange(best.symbol, best.exchange);

// 对外返回时，统一使用 finalSymbol
return {
  symbol: finalSymbol,
  raw_symbol: best.symbol,
  exchange: best.exchange,
  score: best.score,
  // 其他你已有的字段…
};


如果你当前的对外结构是数组，比如 ["NASDAQ:NVDA"]，那就：

const finalSymbol = formatSymbolWithExchange(best.symbol, best.exchange);
return [finalSymbol];


关键点：

不要在其他地方再拼接前缀，尽量把逻辑收敛到这一个 formatSymbolWithExchange，以后要改只改这一处。

结构化日志可以顺手加上一个字段：final_symbol: finalSymbol，方便之后排查。

第 2 步：扩展 SYMBOL_DEBUG 日志，包含 final_symbol

在你之前加的结构化日志位置（Line 593–613），请稍微扩展一下，把最终返回给上游的符号也打印出来，例如：

if (process.env.ENABLE_SYMBOL_DEBUG === 'true') {
  console.log('[SYMBOL_DEBUG] resolution_debug', {
    input,
    exchange_hint,
    candidates: candidates.map(c => ({
      symbol: c.symbol,
      exchange: c.exchange,
      score: c.score,
      description: c.description || null
    })),
    selected: {
      symbol: best.symbol,
      exchange: best.exchange,
      score: best.score
    },
    final_symbol: finalSymbol
  });
}


这样以后再出现类似 COL 的问题，我们能一眼看出：

内部选了谁

实际返回给上游的是哪种形式（是否带 BME: 前缀）

第 3 步：重新跑测试脚本，关注 COL 的结果

保留你之前的 test_symbol_resolver.js，不用重写。

更新代码之后再次运行测试（同样用 ["NVDA","AAPL","TSLA","COL"] 这一组就行）。

请把这次测试的关键输出，通过用户发回来，包括：

test_symbol_resolver.js 的 JSON 结果中，四个条目的 resolved 字段

对应的 [SYMBOL_DEBUG] 日志中，至少一条 COL 的日志（包含 final_symbol 字段的那条）

期望结果：

[
  {
    "input": "NVDA",
    "resolved": ["NASDAQ:NVDA"],
    ...
  },
  {
    "input": "AAPL",
    "resolved": ["NASDAQ:AAPL"],
    ...
  },
  {
    "input": "TSLA",
    "resolved": ["NASDAQ:TSLA"],
    ...
  },
  {
    "input": "COL",
    "resolved": ["BME:COL"],   // ← 这是本轮的关键检查点
    ...
  }
]


日志中理想的片段类似：

[SYMBOL_DEBUG] resolution_debug {
  "input": "COL",
  "candidates": [
    { "symbol": "COL", "exchange": "BMEX", "score": 9xx, ... },
    ...
  ],
  "selected": {
    "symbol": "COL",
    "exchange": "BMEX",
    "score": 9xx
  },
  "final_symbol": "BME:COL"
}


完成以上三步后，请通过用户把：

更新后的 test_symbol_resolver 输出（四个 ticker 的结果）

至少一条 COL 的 SYMBOL_DEBUG 日志

发回来，我会在确认无误后，把「Symbol Resolver + 交易所前缀」这一块标记为 ✅ 完成，再决定下一轮是：

继续扩展更多交易所映射，还是

转向修复 HTTP 服务常驻与 /debug/symbol_resolver_test 接口在线化