给 Replit AI 的工单（直接整段粘贴）
目标：恢复 n8n 的截图策略——优先用截图 SaaS（长延迟 + 元素等待 + 网络静默），只在需要时再用 Browserless。去掉对 TradingView 的 DOM 点选依赖，保证稳定出图。
修改文件：screenshotProviders.js（如文件名不同，按项目实际路径替换）

1) 新增「n8n 风格」截图函数：captureViaScreenshotN8N()
请在 screenshotProviders.js 增加下面这个函数（参数名若与现有封装不同，做等价替换）：
const fetch = require('node-fetch');

function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }
function jitter(ms){ return ms + Math.floor(Math.random()*300); }

async function captureViaScreenshotN8N({ url, dataset }) {
  const start = Date.now();
  const ep  = process.env.SCREENSHOT_API_ENDPOINT; // 例如：https://api.screenshotone.com/take
  const key = process.env.SCREENSHOT_API_KEY;
  if (!ep || !key) throw new Error('screenshot_api_not_configured');

  // —— 还原 n8n 的策略：长延迟 + 元素等待 + 广告/弹窗拦截 + 网络静默
  // 不同供应商参数名可能不同：如果你用的不是 ScreenshotOne，请将字段名对照文档替换。
  const params = new URLSearchParams({
    access_key: key,          // 有的服务叫 token/key
    url,
    full_page: 'true',
    viewport_width: '1920',
    viewport_height: '1080',
    device_scale_factor: '2', // 高清
    block_ads: 'true',
    block_cookie_banners: 'true',
    // 如果供应商支持 element/selector，请保留；不支持就删掉也可以
    element: '.tv-heatmap,.heatmap,.treemap,[data-name*="heatmap"]',
    // 如果供应商支持等待模式：
    // wait_for: 'networkidle',
    delay: '7000',            // 7s，给 TV 充足时间切数据集（n8n 的核心点）
    ttl: '600'                // 10 分钟缓存，提升稳定性
  });

  // —— 两次重试：指数退避
  let lastErr;
  for (let i = 0; i < 3; i++) {
    try {
      const resp = await fetch(`${ep}?${params.toString()}`, { timeout: 25000 });
      if (!resp.ok) throw new Error(`screenshot_http_${resp.status}`);
      const buf = await resp.buffer();

      // 轻量验证：文件尺寸阈值（避免 1x1 空图）；>60KB 视为有效
      if (!buf || buf.length < 60000) throw new Error('screenshot_too_small');

      return { buffer: buf, elapsed_ms: Date.now() - start, validation: 'saas-waited' };
    } catch (e) {
      lastErr = e;
      const backoff = jitter(800 * Math.pow(2, i));
      await sleep(backoff);
      continue;
    }
  }
  throw lastErr || new Error('screenshot_failed');
}


2) 调整主入口顺序：captureHeatmapSmart() 先走截图，再走 Browserless
请把 captureHeatmapSmart 的 provider 顺序改为：
async function captureHeatmapSmart({ tradingViewUrl, dataset, region, sector }) {
  const order = ['screenshot_n8n', 'browserless', 'quickchart']; // 先 SaaS，再 Browserless，最后保底
  for (const p of order) {
    try {
      if (p === 'screenshot_n8n') {
        const r = await captureViaScreenshotN8N({ url: tradingViewUrl, dataset });
        return { provider: 'screenshot', ...r };
      }
      if (p === 'browserless') {
        // 保留你现有的 Browserless 验证与截图，但只作为“尝试”而非必经路径
        const r = await captureViaBrowserless({ url: tradingViewUrl, dataset }); // 复用你现有函数
        return { provider: 'browserless', ...r };
      }
      // quickchart 保底
      const r = await captureViaQuickChart({ dataset });
      return { provider: 'quickchart', ...r };
    } catch (e) {
      // 失败继续回退
      continue;
    }
  }
  throw new Error('all_providers_failed');
}


说明：


截图 SaaS 放到第一顺位，恢复 n8n 的稳定体验。


Browserless 仅作为增强路径（成功则质量更高；失败不影响整体）。


QuickChart 仅保底；出现时请在上游文案标注“降级图”。




3) 关闭（或弱化）Browserless 的强制 DOM 交互


在 Browserless 分支保留清缓存/无痕/就绪等待；


允许 ensureDataset() 失败后不再重试多轮交互，直接抛错进入 ScreenshotN8N 回退；


这让系统“更像 n8n”：不依赖复杂的 UI 脚本。



4) 环境变量
在 Replit Secrets 中确保存在（或新建）：
SCREENSHOT_API_ENDPOINT=（你的截图服务地址，如 https://api.screenshotone.com/take）
SCREENSHOT_API_KEY=（你的截图服务密钥）
BROWSERLESS_API_KEY=（已有）


5) 串行跑用例（避免限流/卡死）
新增或修改测试脚本，按顺序请求 3 个数据集，中间 sleep 1 秒：
node -e "const { captureHeatmapSmart } = require('./screenshotProviders');
(async () => {
  const cases = [
    { dataset:'NIKKEI225', url:'https://www.tradingview.com/heatmap/stock/?color=change&dataset=NIKKEI225&group=sector&blockSize=market_cap' },
    { dataset:'IBEX35',    url:'https://www.tradingview.com/heatmap/stock/?color=change&dataset=IBEX35&group=sector&blockSize=market_cap' },
    { dataset:'SPX500',    url:'https://www.tradingview.com/heatmap/stock/?color=change&dataset=SPX500&group=sector&blockSize=market_cap' },
  ];
  for (const c of cases) {
    try {
      const r = await captureHeatmapSmart({ tradingViewUrl:c.url, dataset:c.dataset });
      console.log(`✅ ${c.dataset}: ${r.provider} ${r.validation} ${r.elapsed_ms}ms ${r.buffer.length}B`);
    } catch(e) {
      console.error(`❌ ${c.dataset}:`, e.message);
    }
    await new Promise(r=>setTimeout(r, 1200));
  }
})();"


6) 文案与降级标记
当 provider==='quickchart' 或 validation==='degraded'/screenshot_too_small 时，在 Telegram 文案里追加一行：
• 注：本次为降级图（数据源波动或受限），已自动回退。


预期效果


回到 n8n 一样的稳定度：靠“延迟 + 元素等待 + 网络静默”的截图服务拿图；


彻底摆脱 TradingView 的 DOM 交互脆弱性；


Browserless 只作为加分项，不会拖垮整体；


你再也不会看到“热力图服务暂时不可用”的大蓝块作为主输出。



需要补充：如果你的截图供应商支持 element 与 wait_until=networkidle 的参数名不同，直接在第 1 步的 params 里替换为官方字段即可。
改完后，回 Telegram 发一句“日本大盘热力图 #dbg”，看是否稳定产出 NIKKEI225 的板块图；我再帮你把元素选择器白名单按供应商文档精调到最稳。
