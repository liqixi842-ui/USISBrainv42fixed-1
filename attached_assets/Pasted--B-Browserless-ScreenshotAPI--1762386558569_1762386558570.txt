选 B：混合策略，我直接把“可落地”的实现给你，按下面贴进去就能跑。思路是：

先试 Browserless（有就用，质量最好）

失败 / 限流 → ScreenshotAPI（延迟足够长、等网络静默）

再失败 → QuickChart 保底

仍保留你的 DOM 强校验；对 ScreenshotAPI 路径做 轻校验（可选 OCR 开关）

1) 环境变量（Replit Secrets）
BROWSERLESS_API_KEY=...       # 你已有
SCREENSHOT_API_ENDPOINT=https://api.screenshotone.com/take   # 或你的 ScreenshotAPI 供应商地址
SCREENSHOT_API_KEY=...        # 新密钥
ENABLE_OCR=false              # 需要时改 true（会用 tesseract.js）


如果你用的不是 ScreenshotOne，只要把 SCREENSHOT_API_ENDPOINT 与参数名替换成你的供应商对应字段即可（下面我用常见参数名，易对照）。

2) provider 顺序与回退（替换/合并进 screenshotProviders.js）
const fetch = require('node-fetch');

// —— 公共：指数 → 展示名
const DATASET_LABEL = { SPX500: 'S&P 500', NIKKEI225: 'Nikkei 225', IBEX35: 'IBEX 35' };

// —— 公共：指数 → 关键字（轻校验/可选 OCR 用）
const MUST_HAVE = {
  SPX500: ['Apple','Microsoft','NVIDIA','Amazon','Meta'],
  NIKKEI225: ['Nikkei','Toyota','Sony','SoftBank','Keyence','任天堂','トヨタ','ソニー'],
  IBEX35: ['IBEX','Santander','BBVA','Iberdrola','Inditex','Repsol']
};

function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }
function jitter(ms){ return ms + Math.floor(Math.random()*300); }

// ========== Browserless 分支：保留你的 DOM 强校验 ==========
async function captureViaBrowserless({ url, dataset }) {
  const start = Date.now();
  const { page, close } = await getBrowserless(); // <- 用你现有的封装
  try {
    await hardCleanAndGoto(page, url);            // <- 你现有清缓存 + goto
    const ok = await ensureDataset(page, dataset);// <- 你已有的 DOM 强校验（A+B+C 失败也会抛错）
    if (!ok) throw new Error('dataset_not_applied');

    const buffer = await page.screenshot({ type:'jpeg', quality:90, fullPage:true });
    return { buffer, elapsed_ms: Date.now()-start, validation:'dom-strong' };
  } finally {
    await close().catch(()=>{});
  }
}

// ========== ScreenshotAPI 分支：长延迟 + 等网络静默 ==========
async function captureViaScreenshotAPI({ url, dataset }) {
  const start = Date.now();
  const ep = process.env.SCREENSHOT_API_ENDPOINT;
  const key = process.env.SCREENSHOT_API_KEY;
  if (!ep || !key) throw new Error('screenshot_api_not_configured');

  // —— 通用参数（不同供应商名稍有不同：对照文档替换）
  const qs = new URLSearchParams({
    access_key: key,                 // 有的叫 token / key
    url,
    full_page: 'true',
    delay: '6000',                   // 6s 给 TradingView 足够时间切集合
    block_ads: 'true',
    block_cookie_banners: 'true',
    ttl: '600',                      // 缓存命中也更稳
    // 有的供应商支持：wait_for=networkidle / element=.heatmap,.treemap
    // wait_for: 'networkidle',
    // element: '.heatmap,.treemap,.tv-heatmap'
  });

  const resp = await fetch(`${ep}?${qs.toString()}`, { timeout: 25000 }); // 25s 保护
  if (!resp.ok) throw new Error(`screenshot_api_http_${resp.status}`);
  const buffer = await resp.buffer();

  // —— 轻校验（可选 OCR，默认关闭）
  const ok = await lightValidate(buffer, MUST_HAVE[dataset] || []);
  if (!ok) throw new Error('image_validation_failed');

  return { buffer, elapsed_ms: Date.now()-start, validation: ok==='ocr' ? 'ocr' : 'light' };
}

// ========== QuickChart 保底 ==========
async function captureViaQuickChart({ dataset }) {
  const start = Date.now();
  const qcUrl = buildQuickChartUrl(dataset); // 你已有
  const resp = await fetch(qcUrl, { timeout: 15000 });
  if (!resp.ok) throw new Error(`quickchart_http_${resp.status}`);
  const buffer = await resp.buffer();
  return { buffer, elapsed_ms: Date.now()-start, validation:'degraded' };
}

// ========== 轻校验（可选 OCR） ==========
async function lightValidate(buffer, mustHave) {
  if (!mustHave || mustHave.length===0) return 'light';
  if (process.env.ENABLE_OCR === 'true') {
    try {
      const { createWorker } = require('tesseract.js');
      const worker = await createWorker({ logger: ()=>{} });
      await worker.loadLanguage('eng+spa+jpn'); await worker.initialize('eng+spa+jpn');
      const { data:{ text } } = await worker.recognize(buffer);
      await worker.terminate();
      const hits = mustHave.filter(k => (text||'').includes(k));
      return hits.length >= 2 ? 'ocr' : false;
    } catch {
      // OCR 不可用时退回轻校验
    }
  }
  // 非 OCR：仅做极简校验（文件大小/维度阈值）
  return buffer?.length > 30_000 ? 'light' : false;
}

// ========== 主入口：先 Browserless → 再 ScreenshotAPI → 再 QuickChart ==========
async function captureHeatmapSmart({ tradingViewUrl, dataset }) {
  const order = ['browserless','screenshot','quickchart'];
  let attempt = 0;

  for (const p of order) {
    attempt++;
    try {
      if (p==='browserless') {
        return { provider:'browserless', ...(await captureViaBrowserless({ url: tradingViewUrl, dataset })) };
      }
      if (p==='screenshot') {
        return { provider:'screenshot', ...(await captureViaScreenshotAPI({ url: tradingViewUrl, dataset })) };
      }
      // p === 'quickchart'
      return { provider:'quickchart', ...(await captureViaQuickChart({ dataset })) };

    } catch (e) {
      // 指数退避 + 报文
      const backoff = jitter(800 * Math.pow(2, attempt-1));
      console.warn(`[fallback] ${p} failed: ${e.message}; backoff=${backoff}ms`);
      await sleep(backoff);
      continue;
    }
  }
  throw new Error('all_providers_failed');
}

module.exports = { captureHeatmapSmart };


说明

Browserless：仍用你现有的 hardCleanAndGoto、ensureDataset（DOM 强校验）。

ScreenshotAPI：把“延迟、广告/弹窗拦截、TTL 缓存、网络静默/元素等待（供应商支持时）”全打开；随后做轻校验（默认不启用 OCR，怕包大）。

QuickChart：保底且带 validation:'degraded'，下游文案可标注“降级图”。

3) 最小化测试脚本（串行，规避 Replit 限流）
node -e "const { captureHeatmapSmart } = require('./screenshotProviders');
(async () => {
  const cases = [
    { dataset:'NIKKEI225', url:'https://www.tradingview.com/heatmap/stock/?color=change&dataset=NIKKEI225&group=sector&blockSize=market_cap' },
    { dataset:'IBEX35',    url:'https://www.tradingview.com/heatmap/stock/?color=change&dataset=IBEX35&group=sector&blockSize=market_cap' },
    { dataset:'SPX500',    url:'https://www.tradingview.com/heatmap/stock/?color=change&dataset=SPX500&group=sector&blockSize=market_cap' },
  ];
  for (const c of cases) {
    try {
      const r = await captureHeatmapSmart({ tradingViewUrl:c.url, dataset:c.dataset });
      console.log(`✅ ${c.dataset}: ${r.provider} ${r.validation} ${r.elapsed_ms}ms ${r.buffer.length}B`);
    } catch(e) {
      console.error(`❌ ${c.dataset}:`, e.message);
    }
    await new Promise(r=>setTimeout(r, 1200));
  }
})();"

4) 给 Replit AI 的自然语言工单（直接粘贴）

任务：实现混合截图策略（Browserless→ScreenshotAPI→QuickChart）并串行执行。

在 screenshotProviders.js 添加 captureViaScreenshotAPI() 与 lightValidate()，参数包含 full_page=true、delay=6000、block_ads=true、block_cookie_banners=true、可选 wait_for=networkidle 与 element=.heatmap,.treemap（按供应商文档映射）。

在 captureHeatmapSmart() 中按顺序尝试：Browserless（DOM 强校验通过才截图）→ ScreenshotAPI（轻校验/OCR 命中≥2 才通过）→ QuickChart（validation:"degraded"）。

为每次失败增加指数退避（800ms * 2^n + 随机 0–300ms），并串行执行用例，避免 Promise.all 并发。

将 SCREENSHOT_API_ENDPOINT/SCREENSHOT_API_KEY 写入 Replit Secrets；默认 ENABLE_OCR=false，需要时改 true 并安装 tesseract.js（可延后）。

日志输出统一：dataset / provider / validation / elapsed_ms / sizeB，错误打印 screenshot_api_http_* / dataset_not_applied 等关键码。