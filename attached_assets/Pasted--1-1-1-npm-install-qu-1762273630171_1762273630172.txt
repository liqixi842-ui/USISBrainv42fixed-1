赞同你的工程取舍。我们走你说的阶段1：最小可用版本，一步一确认。我先给只做一件事的第1步。

【第1步｜安装依赖 + 加入最小可视化函数（先不接主流程）】

终端安装：

npm install quickchart-js


在 index.js 顶部（其他 require 附近）加入：

const QuickChart = require('quickchart-js');


在 index.js 任意 util 区域新增这两个函数（先只支持 single；不接 LLM、不做 grid）：

// —— L2: 可视化需求（最小版）：复用 L1 的 intent ——
// 约定：如果 L1 intent.mode 包含 'cpi'/'unrate'/'gdp'/'rate'，只做单指标图；
// 如果是 'premarket' 或文本里含 “宏观/总览”，先不画图（纯文字）。
function detectVisualizationNeedSimple(l1Intent = {}, text = '') {
  const t = (text || '').toLowerCase();
  const mode = (l1Intent.mode || '').toLowerCase();
  // 关键词到FRED指标映射
  const map = [
    { test: /(cpi|通胀|物价)/, metric: 'CPIAUCSL' },
    { test: /(失业|unrate|就业)/, metric: 'UNRATE' },
    { test: /(gdp)/, metric: 'GDPC1' },
    { test: /(利率|fedfunds|联邦基金|加息|降息)/, metric: 'FEDFUNDS' },
  ];
  for (const m of map) {
    if (m.test.test(t) || m.test.test(mode)) {
      return { needChart: true, metrics: [m.metric], style: 'single', reason: 'rule-min' };
    }
  }
  // 盘前/宏观总览 → 先不画图，纯文字
  if (/premarket|宏观|总览|overview/.test(t) || /premarket/.test(mode)) {
    return { needChart: false, metrics: [], style: 'none', reason: 'overview-text' };
  }
  return { needChart: false, metrics: [], style: 'none', reason: 'default-text' };
}

// —— 最小图表生成（single） ——
// 输入：macro 为 FRED 拉取的 market_data.macro；metrics: ['CPIAUCSL']；style: 'single'
async function generateSmartChartSingle(macro, metric) {
  const series = (macro?.[metric]?.observations || []).map(o => ({ date: o.date.slice(0,7), value: o.value }));
  if (series.length < 2) return null;

  const qc = new QuickChart();
  qc.setConfig({
    type: 'line',
    data: {
      labels: series.map(p => p.date),
      datasets: [{ label: metric, data: series.map(p => p.value), fill: false, tension: 0.25 }]
    },
    options: {
      plugins: { legend: { display: false }, title: { display: true, text: metric } },
      scales: { x: { ticks: { maxTicksLimit: 8 } } }
    }
  });
  return await qc.getShortUrl(); // 返回可直接发到 Telegram 的图片URL
}


说明：这一步只把依赖与最小版智能可视化能力加进代码库，暂不接 orchestrate 主流程，确保编译通过且包可用。

完成后回我一句：“第1步OK”。
我随即给第2步：在 L2 出口接上 detectVisualizationNeedSimple → 生成单图 → 把动作写进响应 actions（N8N 只需遍历 actions 逐条发图即可）。