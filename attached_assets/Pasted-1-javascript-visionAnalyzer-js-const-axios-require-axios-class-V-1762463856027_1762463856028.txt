1. ä¿®å¤è§†è§‰åˆ†ææ¨¡å—
javascript
// visionAnalyzer.js - æ–°å¢è§†è§‰åˆ†ææ¨¡å—
const axios = require('axios');

class VisionAnalyzer {
  constructor() {
    this.openaiApiKey = process.env.OPENAI_API_KEY;
  }

  async analyzeHeatmapImage(imageBuffer, marketContext) {
    try {
      const base64Image = imageBuffer.toString('base64');
      
      const response = await axios.post('https://api.openai.com/v1/chat/completions', {
        model: 'gpt-4o',
        messages: [{
          role: 'user',
          content: [
            {
              type: 'text',
              text: this.buildVisionPrompt(marketContext)
            },
            {
              type: 'image_url',
              image_url: {
                url: `data:image/png;base64,${base64Image}`,
                detail: 'high'
              }
            }
          ]
        }],
        max_tokens: 2000,
        temperature: 0.1
      }, {
        headers: {
          'Authorization': `Bearer ${this.openaiApiKey}`,
          'Content-Type': 'application/json'
        }
      });

      return this.parseVisionResponse(response.data.choices[0].message.content);
    } catch (error) {
      console.error('Vision analysis failed:', error);
      throw new Error(`è§†è§‰åˆ†æå¤±è´¥: ${error.message}`);
    }
  }

  buildVisionPrompt(marketContext) {
    return `ä½œä¸ºä¸“ä¸šé‡‘èåˆ†æå¸ˆï¼Œæ·±åº¦åˆ†æè¿™å¼ ${marketContext.index}çƒ­åŠ›å›¾ï¼š

ã€è§†è§‰ç‰¹å¾æå–ã€‘
1. é¢œè‰²åˆ†å¸ƒåˆ†æï¼š
   - çº¢è‰²æ¿å—å æ¯”åŠå¼ºåº¦ï¼ˆä¸Šæ¶¨ï¼‰
   - ç»¿è‰²æ¿å—å æ¯”åŠå¼ºåº¦ï¼ˆä¸‹è·Œï¼‰ 
   - é¢œè‰²é¥±å’Œåº¦å¯¹åº”çš„æ¶¨è·Œå¹…ç¨‹åº¦

2. å¸‚å€¼æƒé‡åˆ†æï¼š
   - å¤§å¸‚å€¼è‚¡ç¥¨ï¼ˆå¤§åŒºå—ï¼‰è¡¨ç°
   - ä¸­å°å¸‚å€¼è‚¡ç¥¨ï¼ˆå°åŒºå—ï¼‰è¡¨ç°
   - æƒé‡è‚¡å¯¹æŒ‡æ•°çš„å½±å“ç¨‹åº¦

3. æ¿å—è½®åŠ¨ç‰¹å¾ï¼š
   - å¼ºåŠ¿æ¿å—é›†ä¸­åº¦
   - å¼±åŠ¿æ¿å—åˆ†å¸ƒæƒ…å†µ
   - æ¿å—é—´çš„ç›¸å…³æ€§æ¨¡å¼

4. å¸‚åœºå¹¿åº¦æŒ‡æ ‡ï¼š
   - ä¸Šæ¶¨è‚¡ç¥¨æ•°é‡å æ¯”
   - ä¸‹è·Œè‚¡ç¥¨æ•°é‡å æ¯”
   - æ¶¨è·Œåœæ¿è‚¡ç¥¨è¯†åˆ«

ã€ä¸“ä¸šæ´å¯Ÿã€‘
- è¯†åˆ«å¼‚å¸¸æ³¢åŠ¨ä¸ªè‚¡
- æ¿å—è½®åŠ¨èŠ‚å¥åˆ¤æ–­
- å¸‚åœºæƒ…ç»ªæ¸©åº¦è®¡
- å…³é”®æ”¯æ’‘é˜»åŠ›ä½è¯†åˆ«

è¯·æä¾›å…·ä½“æ•°å€¼ä¼°è®¡å’Œå¯è§†åŒ–ç‰¹å¾æè¿°ã€‚`;
  }

  parseVisionResponse(visionText) {
    // è§£æè§†è§‰åˆ†æçš„æ–‡æœ¬å“åº”ï¼Œæå–ç»“æ„åŒ–æ•°æ®
    const sectors = visionText.match(/[ğŸŸ¥ğŸŸ©ğŸŸ¨][^:]+:[^%\n]+%?/g) || [];
    const metrics = visionText.match(/(ä¸Šæ¶¨|ä¸‹è·Œ|å æ¯”|å¹¿åº¦)[^%\d]*(\d+\.?\d*)%/g) || [];
    
    return {
      rawAnalysis: visionText,
      sectors: this.extractSectors(sectors),
      metrics: this.extractMetrics(metrics),
      timestamp: new Date().toISOString()
    };
  }

  extractSectors(sectorMatches) {
    return sectorMatches.map(sector => {
      const match = sector.match(/([ğŸŸ¥ğŸŸ©ğŸŸ¨])([^:]+):\s*([+-]?\d+\.?\d*)%?/);
      return match ? {
        trend: match[1] === 'ğŸŸ¥' ? 'up' : match[1] === 'ğŸŸ©' ? 'down' : 'neutral',
        name: match[2].trim(),
        change: parseFloat(match[3]) || 0
      } : null;
    }).filter(Boolean);
  }

  extractMetrics(metricMatches) {
    const metrics = {};
    metricMatches.forEach(metric => {
      if (metric.includes('ä¸Šæ¶¨') && metric.includes('%')) {
        metrics.advanceRatio = parseFloat(metric.match(/(\d+\.?\d*)%/)[1]);
      } else if (metric.includes('ä¸‹è·Œ') && metric.includes('%')) {
        metrics.declineRatio = parseFloat(metric.match(/(\d+\.?\d*)%/)[1]);
      }
    });
    return metrics;
  }
}

module.exports = VisionAnalyzer;
2. å¢å¼ºæ•°æ®æºé›†æˆæ¨¡å—
javascript
// enhancedDataBroker.js - å¢å¼ºæ•°æ®ç»çºªäºº
const axios = require('axios');

class EnhancedDataBroker {
  constructor() {
    this.finnhubKey = process.env.FINNHUB_API_KEY;
    this.fredKey = process.env.FRED_API_KEY;
    this.newsKey = process.env.NEWS_API_KEY;
  }

  async fetchComprehensiveMarketData(index, region, sector = null) {
    try {
      const [indexData, components, sectorData, economicData, newsData] = await Promise.all([
        this.fetchIndexData(index),
        this.fetchIndexComponents(index),
        this.fetchSectorPerformance(region, sector),
        this.fetchEconomicIndicators(region),
        this.fetchSectorNews(region, sector)
      ]);

      return {
        index: indexData,
        components: components,
        sectors: sectorData,
        economics: economicData,
        news: newsData,
        marketBreadth: this.calculateMarketBreadth(components),
        technicals: this.calculateTechnicalIndicators(components)
      };
    } catch (error) {
      console.error('Data fetch failed:', error);
      throw new Error(`æ•°æ®è·å–å¤±è´¥: ${error.message}`);
    }
  }

  async fetchIndexData(index) {
    const response = await axios.get(`https://finnhub.io/api/v1/quote?symbol=${index}&token=${this.finnhubKey}`);
    return {
      symbol: index,
      price: response.data.c,
      change: response.data.d,
      changePercent: response.data.dp,
      high: response.data.h,
      low: response.data.l,
      volume: response.data.v,
      timestamp: new Date(response.data.t * 1000)
    };
  }

  async fetchIndexComponents(index) {
    // è·å–æŒ‡æ•°æˆåˆ†è‚¡ - éœ€è¦æ ¹æ®å…·ä½“æŒ‡æ•°è°ƒæ•´
    const symbols = this.getIndexSymbols(index);
    
    const componentData = await Promise.all(
      symbols.map(async symbol => {
        try {
          const quote = await axios.get(`https://finnhub.io/api/v1/quote?symbol=${symbol}&token=${this.finnhubKey}`);
          const profile = await axios.get(`https://finnhub.io/api/v1/stock/profile2?symbol=${symbol}&token=${this.finnhubKey}`);
          
          return {
            symbol: symbol,
            name: profile.data.name,
            price: quote.data.c,
            change: quote.data.d,
            changePercent: quote.data.dp,
            volume: quote.data.v,
            marketCap: profile.data.marketCapitalization,
            sector: profile.data.finnhubIndustry,
            timestamp: new Date(quote.data.t * 1000)
          };
        } catch (error) {
          console.warn(`Failed to fetch data for ${symbol}:`, error.message);
          return null;
        }
      })
    );

    return componentData.filter(Boolean);
  }

  async fetchSectorPerformance(region, sector) {
    // è·å–æ¿å—è¡¨ç°æ•°æ®
    const response = await axios.get(`https://finnhub.io/api/v1/stock/sector?token=${this.finnhubKey}`);
    
    const regionalSectors = response.data.filter(s => 
      s.region === this.mapRegionToCode(region)
    );
    
    return sector ? 
      regionalSectors.filter(s => s.sector === sector) :
      regionalSectors;
  }

  async fetchEconomicIndicators(region) {
    const indicators = this.getRegionalIndicators(region);
    
    const economicData = await Promise.all(
      indicators.map(async indicator => {
        try {
          const response = await axios.get(
            `https://api.stlouisfed.org/fred/series/observations?series_id=${indicator.id}&api_key=${this.fredKey}&file_type=json&sort_order=desc&limit=1`
          );
          
          return {
            indicator: indicator.name,
            value: response.data.observations[0]?.value,
            date: response.data.observations[0]?.date,
            unit: indicator.unit
          };
        } catch (error) {
          console.warn(`Failed to fetch ${indicator.name}:`, error.message);
          return null;
        }
      })
    );

    return economicData.filter(Boolean);
  }

  async fetchSectorNews(region, sector) {
    const query = sector ? `${sector} ${this.mapRegionToName(region)}` : this.mapRegionToName(region);
    
    const response = await axios.get(`https://newsapi.org/v2/everything?q=${encodeURIComponent(query)}&language=en&sortBy=publishedAt&apiKey=${this.newsKey}`);
    
    return {
      articles: response.data.articles.slice(0, 10).map(article => ({
        title: article.title,
        description: article.description,
        url: article.url,
        publishedAt: article.publishedAt,
        source: article.source.name,
        sentiment: this.analyzeSentiment(article.title + ' ' + article.description)
      })),
      totalResults: response.data.totalResults
    };
  }

  calculateMarketBreadth(components) {
    const advances = components.filter(c => c.change > 0).length;
    const declines = components.filter(c => c.change < 0).length;
    const unchanged = components.filter(c => c.change === 0).length;
    
    return {
      advances,
      declines, 
      unchanged,
      advanceDeclineRatio: advances / (declines || 1),
      advancePercentage: (advances / components.length) * 100
    };
  }

  calculateTechnicalIndicators(components) {
    const changes = components.map(c => c.changePercent).filter(Boolean);
    
    return {
      averageChange: changes.reduce((a, b) => a + b, 0) / changes.length,
      maxGain: Math.max(...changes),
      maxLoss: Math.min(...changes),
      volatility: this.calculateVolatility(changes)
    };
  }

  // è¾…åŠ©æ–¹æ³•
  getIndexSymbols(index) {
    const symbolMap = {
      'IBEX35': ['SAN.MC', 'BBVA.MC', 'ITX.MC', 'TEF.MC', 'REP.MC', 'CABK.MC', 'ENG.MC', 'IAG.MC', 'FER.MC', 'GRF.MC'],
      'NIKKEI225': ['7203.T', '6758.T', '6861.T', '8306.T', '9433.T', '9984.T', '9432.T', '7267.T', '4502.T', '6098.T'],
      'DAX': ['SAP.DE', 'SIE.DE', 'ALV.DE', 'DTE.DE', 'ADS.DE', 'VOW3.DE', 'DBK.DE', 'BMW.DE', 'BAYN.DE', 'BAS.DE']
    };
    
    return symbolMap[index] || [];
  }

  mapRegionToCode(region) {
    const regionMap = {
      'ES': 'EU',
      'JP': 'AS', 
      'DE': 'EU',
      'US': 'NA'
    };
    return regionMap[region] || 'GLOBAL';
  }

  mapRegionToName(region) {
    const nameMap = {
      'ES': 'Spain',
      'JP': 'Japan',
      'DE': 'Germany', 
      'US': 'United States'
    };
    return nameMap[region] || region;
  }

  getRegionalIndicators(region) {
    const indicatorMap = {
      'ES': [
        { id: 'CLVMNACSCAB1GQES', name: 'GDP Growth', unit: '%' },
        { id: 'CPHPTT01ESM659N', name: 'Inflation Rate', unit: '%' },
        { id: 'LRUN64TTESQ156S', name: 'Unemployment Rate', unit: '%' }
      ],
      'JP': [
        { id: 'JPNRGDPEXP', name: 'GDP Growth', unit: '%' },
        { id: 'JPNCPIALLQINMEI', name: 'Inflation Rate', unit: '%' },
        { id: 'LRUN64TTJPQ156S', name: 'Unemployment Rate', unit: '%' }
      ]
    };
    
    return indicatorMap[region] || [];
  }

  analyzeSentiment(text) {
    const positiveWords = ['growth', 'gain', 'rise', 'bullish', 'positive', 'strong', 'recovery', 'optimistic'];
    const negativeWords = ['decline', 'fall', 'drop', 'bearish', 'negative', 'weak', 'recession', 'pessimistic'];
    
    const words = text.toLowerCase().split(/\s+/);
    const positiveCount = words.filter(word => positiveWords.includes(word)).length;
    const negativeCount = words.filter(word => negativeWords.includes(word)).length;
    
    return positiveCount > negativeCount ? 'positive' : 
           negativeCount > positiveCount ? 'negative' : 'neutral';
  }

  calculateVolatility(changes) {
    const mean = changes.reduce((a, b) => a + b, 0) / changes.length;
    const variance = changes.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / changes.length;
    return Math.sqrt(variance);
  }
}

module.exports = EnhancedDataBroker;
3. ä¸“ä¸šæŠ¥å‘Šç”Ÿæˆå™¨
javascript
// professionalReporter.js - ä¸“ä¸šæŠ¥å‘Šç”Ÿæˆ
const { GPT5Brain } = require('./gpt5Brain'); // å‡è®¾å·²æœ‰GPT5æ¨¡å—

class ProfessionalReporter {
  constructor() {
    this.gpt5 = new GPT5Brain();
  }

  async generateHeatmapAnalysisReport(visualAnalysis, marketData, economicData, newsData) {
    const analysisContext = this.buildAnalysisContext(visualAnalysis, marketData, economicData, newsData);
    
    const prompt = this.buildProfessionalPrompt(analysisContext);
    
    try {
      const analysis = await this.gpt5.generateAnalysis(prompt);
      return this.formatProfessionalReport(analysis, analysisContext);
    } catch (error) {
      return this.generateFallbackReport(analysisContext);
    }
  }

  buildAnalysisContext(visualAnalysis, marketData, economicData, newsData) {
    return {
      // è§†è§‰åˆ†ææ•°æ®
      visual: {
        sectors: visualAnalysis.sectors,
        metrics: visualAnalysis.metrics,
        rawInsights: visualAnalysis.rawAnalysis
      },
      
      // å¸‚åœºæ•°æ®
      market: {
        index: marketData.index,
        components: marketData.components,
        sectors: marketData.sectors,
        breadth: marketData.marketBreadth,
        technicals: marketData.technicals
      },
      
      // ç»æµæ•°æ®
      economics: economicData,
      
      // æ–°é—»æƒ…ç»ª
      news: {
        articles: newsData.articles,
        sentiment: this.aggregateNewsSentiment(newsData.articles),
        totalResults: newsData.totalResults
      },
      
      // ç»¼åˆåˆ†æ
      synthesis: this.synthesizeData(visualAnalysis, marketData, economicData, newsData)
    };
  }

  buildProfessionalPrompt(context) {
    return `ä½œä¸ºé¡¶çº§é‡‘èåˆ†æå¸ˆï¼ŒåŸºäºä»¥ä¸‹å¤šç»´æ•°æ®ç”Ÿæˆä¸“ä¸šçš„çƒ­åŠ›å›¾åˆ†ææŠ¥å‘Šï¼š

ã€å¸‚åœºæ¦‚å†µã€‘
- æŒ‡æ•°: ${context.market.index.symbol} 
- å½“å‰ä»·æ ¼: ${context.market.index.price} (${context.market.index.change >= 0 ? '+' : ''}${context.market.index.changePercent}%)
- å¸‚åœºå¹¿åº¦: ä¸Šæ¶¨${context.market.breadth.advances}å®¶, ä¸‹è·Œ${context.market.breadth.declines}å®¶

ã€è§†è§‰åˆ†ææ´å¯Ÿã€‘
${context.visual.rawInsights}

ã€å®æ—¶æ•°æ®éªŒè¯ã€‘
${this.formatMarketData(context.market)}

ã€å®è§‚ç»æµèƒŒæ™¯ã€‘
${this.formatEconomicData(context.economics)}

ã€æ–°é—»æƒ…ç»ªåˆ†æã€‘
${this.formatNewsData(context.news)}

ã€ä¸“ä¸šåˆ†æè¦æ±‚ã€‘
1. è¯†åˆ«3ä¸ªå…³é”®äº¤æ˜“æœºä¼š
2. è¯„ä¼°å¸‚åœºé£é™©ç­‰çº§(1-5çº§)
3. ç»™å‡ºå…·ä½“æ¿å—é…ç½®å»ºè®®
4. æä¾›æŠ€æœ¯ä½åˆ†æ
5. çŸ­æœŸ(1-3å¤©)å¸‚åœºå±•æœ›

è¯·ä»¥ä¸“ä¸šæœºæ„ç ”æŠ¥æ ¼å¼è¾“å‡ºï¼ŒåŒ…å«æ•°æ®æ”¯æ’‘çš„å…·ä½“è§‚ç‚¹ã€‚`;
  }

  formatMarketData(marketData) {
    const topGainers = marketData.components
      .filter(c => c.changePercent > 0)
      .sort((a, b) => b.changePercent - a.changePercent)
      .slice(0, 3);
      
    const topLosers = marketData.components
      .filter(c => c.changePercent < 0)
      .sort((a, b) => a.changePercent - b.changePercent)
      .slice(0, 3);
    
    return `é¢†æ¶¨è‚¡: ${topGainers.map(s => `${s.symbol} +${s.changePercent.toFixed(2)}%`).join(', ')}
é¢†è·Œè‚¡: ${topLosers.map(s => `${s.symbol} ${s.changePercent.toFixed(2)}%`).join(', ')}
æ¿å—è¡¨ç°: ${marketData.sectors.map(s => `${s.sector}: ${s.change}%`).join(', ')}`;
  }

  formatEconomicData(economicData) {
    return economicData.map(e => `${e.indicator}: ${e.value}${e.unit}`).join('\n');
  }

  formatNewsData(newsData) {
    const sentimentCount = {
      positive: newsData.articles.filter(a => a.sentiment === 'positive').length,
      negative: newsData.articles.filter(a => a.sentiment === 'negative').length,
      neutral: newsData.articles.filter(a => a.sentiment === 'neutral').length
    };
    
    return `æ–°é—»æƒ…ç»ª: æ­£é¢${sentimentCount.positive}ç¯‡, è´Ÿé¢${sentimentCount.negative}ç¯‡, ä¸­æ€§${sentimentCount.neutral}ç¯‡
å…³é”®æ ‡é¢˜: ${newsData.articles.slice(0, 3).map(a => a.title).join(' | ')}`;
  }

  synthesizeData(visualAnalysis, marketData, economicData, newsData) {
    const synthesis = {
      confidence: 0,
      keyInsights: [],
      riskLevel: 3,
      opportunities: []
    };
    
    // æ•°æ®ä¸€è‡´æ€§éªŒè¯
    const visualSectors = visualAnalysis.sectors.map(s => s.name);
    const actualSectors = marketData.sectors.map(s => s.sector);
    const sectorOverlap = visualSectors.filter(s => actualSectors.includes(s));
    
    synthesis.confidence = (sectorOverlap.length / Math.max(visualSectors.length, 1)) * 100;
    
    // ç”Ÿæˆå…³é”®æ´å¯Ÿ
    if (marketData.breadth.advancePercentage > 60) {
      synthesis.keyInsights.push('å¸‚åœºå¹¿åº¦å¥åº·ï¼Œä¸Šæ¶¨è‚¡ç¥¨å æ¯”è¶…è¿‡60%');
    }
    
    if (newsData.sentiment === 'positive' && marketData.index.changePercent > 0) {
      synthesis.keyInsights.push('æ–°é—»æƒ…ç»ªä¸ä»·æ ¼èµ°åŠ¿ä¸€è‡´ï¼Œä¿¡å¿ƒè¾ƒå¼º');
    }
    
    // é£é™©è¯„ä¼°
    if (marketData.technicals.volatility > 2) {
      synthesis.riskLevel = 4;
    } else if (economicData.some(e => e.indicator.includes('Unemployment') && parseFloat(e.value) > 8)) {
      synthesis.riskLevel = 4;
    }
    
    return synthesis;
  }

  aggregateNewsSentiment(articles) {
    const sentiments = articles.map(a => a.sentiment);
    const positiveCount = sentiments.filter(s => s === 'positive').length;
    const negativeCount = sentiments.filter(s => s === 'negative').length;
    
    return positiveCount > negativeCount ? 'positive' :
           negativeCount > positiveCount ? 'negative' : 'neutral';
  }

  formatProfessionalReport(analysis, context) {
    return {
      title: `ğŸ“Š ${context.market.index.symbol} çƒ­åŠ›å›¾æ·±åº¦åˆ†ææŠ¥å‘Š`,
      executiveSummary: this.extractExecutiveSummary(analysis),
      marketOverview: this.formatMarketOverview(context.market),
      sectorAnalysis: this.formatSectorAnalysis(context.visual.sectors, context.market.sectors),
      technicalAnalysis: this.formatTechnicalAnalysis(context.market.technicals),
      tradingOpportunities: this.extractTradingOpportunities(analysis),
      riskAssessment: context.synthesis.riskLevel,
      outlook: this.extractOutlook(analysis),
      dataConfidence: `${context.synthesis.confidence.toFixed(1)}%`,
      timestamp: new Date().toISOString(),
      rawAnalysis: analysis
    };
  }

  extractExecutiveSummary(analysis) {
    // ä»AIåˆ†æä¸­æå–æ‰§è¡Œæ‘˜è¦
    const sentences = analysis.split(/[.!?]+/);
    return sentences.slice(0, 3).join('. ') + '.';
  }

  formatMarketOverview(marketData) {
    return {
      indexPerformance: `${marketData.index.symbol}: ${marketData.index.price} (${marketData.index.change >= 0 ? '+' : ''}${marketData.index.changePercent}%)`,
      marketBreadth: `ä¸Šæ¶¨${marketData.breadth.advances} / ä¸‹è·Œ${marketData.breadth.declines} / å¹³ç›˜${marketData.breadth.unchanged}`,
      volume: `æˆäº¤é‡: ${marketData.index.volume?.toLocaleString() || 'N/A'}`,
      volatility: `æ³¢åŠ¨ç‡: ${marketData.technicals.volatility.toFixed(2)}%`
    };
  }

  formatSectorAnalysis(visualSectors, actualSectors) {
    const sectors = visualSectors.map(vs => {
      const actual = actualSectors.find(as => as.sector === vs.name);
      return {
        name: vs.name,
        visualTrend: vs.trend,
        visualChange: vs.change,
        actualChange: actual?.change || null,
        consistency: actual ? Math.abs(vs.change - actual.change) < 1 : false
      };
    });
    
    return sectors;
  }

  formatTechnicalAnalysis(technicals) {
    return {
      averageChange: `${technicals.averageChange.toFixed(2)}%`,
      maxGain: `+${technicals.maxGain.toFixed(2)}%`,
      maxLoss: `${technicals.maxLoss.toFixed(2)}%`,
      volatility: `${technicals.volatility.toFixed(2)}%`
    };
  }

  extractTradingOpportunities(analysis) {
    const opportunityRegex = /(å…³æ³¨|å»ºè®®|æœºä¼š|æ¨è)[^ã€‚ï¼ï¼Ÿ]+[ã€‚ï¼ï¼Ÿ]/g;
    const matches = analysis.match(opportunityRegex) || [];
    return matches.slice(0, 3);
  }

  extractOutlook(analysis) {
    const outlookRegex = /(é¢„è®¡|é¢„æœŸ|å±•æœ›|å‰æ™¯)[^ã€‚ï¼ï¼Ÿ]+[ã€‚ï¼ï¼Ÿ]/g;
    const matches = analysis.match(outlookRegex) || [];
    return matches[0] || 'å¸‚åœºå±•æœ›éœ€ç»“åˆæ›´å¤šæ•°æ®åˆ¤æ–­';
  }

  generateFallbackReport(context) {
    return {
      title: `ğŸ“Š ${context.market.index.symbol} çƒ­åŠ›å›¾åˆ†ææŠ¥å‘Š`,
      executiveSummary: 'åŸºäºè§†è§‰åˆ†æå’Œå¸‚åœºæ•°æ®çš„ç»¼åˆè¯„ä¼°',
      marketOverview: this.formatMarketOverview(context.market),
      sectorAnalysis: this.formatSectorAnalysis(context.visual.sectors, context.market.sectors),
      dataSources: 'è§†è§‰åˆ†æ + å®æ—¶å¸‚åœºæ•°æ® + å®è§‚ç»æµæŒ‡æ ‡',
      confidence: 'æ•°æ®éªŒè¯ä¸­',
      timestamp: new Date().toISOString(),
      note: 'AIåˆ†ææœåŠ¡æš‚æ—¶ä¸å¯ç”¨ï¼Œæ­¤ä¸ºåŸºäºæ•°æ®çš„ç›´æ¥åˆ†æ'
    };
  }
}

module.exports = ProfessionalReporter;
4. ä¸»æ§åˆ¶å™¨é›†æˆ
javascript
// enhancedHeatmapController.js - å¢å¼ºçƒ­åŠ›å›¾æ§åˆ¶å™¨
const VisionAnalyzer = require('./visionAnalyzer');
const EnhancedDataBroker = require('./enhancedDataBroker');
const ProfessionalReporter = require('./professionalReporter');
const axios = require('axios');

class EnhancedHeatmapController {
  constructor() {
    this.visionAnalyzer = new VisionAnalyzer();
    this.dataBroker = new EnhancedDataBroker();
    this.reporter = new ProfessionalReporter();
  }

  async processHeatmapRequest(region, index, sector = null) {
    console.log(`ğŸš€ å¼€å§‹å¤„ç†çƒ­åŠ›å›¾è¯·æ±‚: ${region}-${index}-${sector}`);
    
    try {
      // 1. ç”Ÿæˆçƒ­åŠ›å›¾
      const heatmapUrl = this.buildTradingViewURL(region, index, sector);
      console.log('ğŸ“Š ç”Ÿæˆçƒ­åŠ›å›¾URL:', heatmapUrl);
      
      const screenshot = await this.captureHeatmap(heatmapUrl);
      console.log('âœ… çƒ­åŠ›å›¾æˆªå›¾å®Œæˆ');
      
      // 2. å¹¶è¡Œå¤„ç†ï¼šè§†è§‰åˆ†æ + æ•°æ®è·å–
      const [imageBuffer, marketData] = await Promise.all([
        this.downloadImage(screenshot.url),
        this.dataBroker.fetchComprehensiveMarketData(index, region, sector)
      ]);
      
      console.log('ğŸ“¥ æ•°æ®è·å–å®Œæˆ:', {
        components: marketData.components.length,
        sectors: marketData.sectors.length,
        economics: marketData.economics.length,
        news: marketData.news.articles.length
      });
      
      // 3. è§†è§‰åˆ†æ
      const visualAnalysis = await this.visionAnalyzer.analyzeHeatmapImage(
        imageBuffer, 
        { region, index, sector }
      );
      console.log('ğŸ‘ï¸ è§†è§‰åˆ†æå®Œæˆ:', visualAnalysis.sectors.length, 'ä¸ªæ¿å—è¯†åˆ«');
      
      // 4. ç”Ÿæˆä¸“ä¸šæŠ¥å‘Š
      const report = await this.reporter.generateHeatmapAnalysisReport(
        visualAnalysis,
        marketData,
        marketData.economics,
        marketData.news
      );
      
      console.log('ğŸ“ˆ ä¸“ä¸šæŠ¥å‘Šç”Ÿæˆå®Œæˆ');
      
      return {
        success: true,
        heatmapImage: screenshot.url,
        report: report,
        rawData: {
          visual: visualAnalysis,
          market: marketData
        },
        metadata: {
          processingTime: Date.now(),
          dataSources: ['TradingView', 'Finnhub', 'FRED', 'NewsAPI', 'OpenAI Vision'],
          dataPoints: marketData.components.length + marketData.sectors.length
        }
      };
      
    } catch (error) {
      console.error('âŒ çƒ­åŠ›å›¾å¤„ç†å¤±è´¥:', error);
      
      // é™çº§å¤„ç†
      return await this.fallbackProcessing(region, index, sector, error);
    }
  }

  buildTradingViewURL(region, index, sector) {
    const baseURL = 'https://www.tradingview.com/heatmap/stock/';
    const params = new URLSearchParams({
      color: 'change',
      dataset: index,
      group: 'sector',
      blockSize: 'market_cap_basic',
      blockColor: 'change'
    });
    
    if (sector) {
      params.append('sector', sector);
    }
    
    return `${baseURL}?${params.toString()}`;
  }

  async captureHeatmap(url) {
    // ä½¿ç”¨n8næˆªå›¾æœåŠ¡
    const response = await axios.post(process.env.N8N_WEBHOOK_URL, {
      url: url,
      options: {
        fullPage: false,
        viewport: { width: 1200, height: 800 },
        waitFor: 3000
      }
    });
    
    return response.data;
  }

  async downloadImage(url) {
    const response = await axios.get(url, { responseType: 'arraybuffer' });
    return Buffer.from(response.data);
  }

  async fallbackProcessing(region, index, sector, error) {
    console.log('ğŸ”„ å¯ç”¨é™çº§å¤„ç†æ¨¡å¼');
    
    try {
      // ä»…è·å–åŸºç¡€æ•°æ®
      const marketData = await this.dataBroker.fetchComprehensiveMarketData(index, region, sector);
      
      const fallbackReport = {
        title: `ğŸ“Š ${index} åŸºç¡€åˆ†ææŠ¥å‘Š`,
        executiveSummary: 'å®Œæ•´è§†è§‰åˆ†æä¸å¯ç”¨ï¼ŒåŸºäºå¸‚åœºæ•°æ®æä¾›åŸºç¡€åˆ†æ',
        marketOverview: this.reporter.formatMarketOverview(marketData),
        dataSources: ['Finnhub', 'FRED', 'NewsAPI'],
        error: error.message,
        timestamp: new Date().toISOString(),
        recommendation: 'å»ºè®®æ£€æŸ¥è§†è§‰åˆ†ææœåŠ¡é…ç½®'
      };
      
      return {
        success: false,
        fallback: true,
        report: fallbackReport,
        rawData: { market: marketData }
      };
    } catch (fallbackError) {
      console.error('âŒ é™çº§å¤„ç†ä¹Ÿå¤±è´¥:', fallbackError);
      throw new Error(`çƒ­åŠ›å›¾åˆ†æå®Œå…¨å¤±è´¥: ${error.message}, é™çº§å¤„ç†: ${fallbackError.message}`);
    }
  }
}

module.exports = EnhancedHeatmapController;
5. é›†æˆåˆ°ç°æœ‰ç³»ç»Ÿ
javascript
// åœ¨ç°æœ‰çš„çƒ­åŠ›å›¾å¤„ç†æµç¨‹ä¸­æ›¿æ¢
const EnhancedHeatmapController = require('./enhancedHeatmapController');

// æ›¿æ¢ç°æœ‰çš„heatmapIntentParser.jså¤„ç†é€»è¾‘
async function handleHeatmapRequest(message) {
  const controller = new EnhancedHeatmapController();
  
  // è§£æåœ°åŒºã€æŒ‡æ•°ã€æ¿å—
  const { region, index, sector } = parseHeatmapIntent(message);
  
  // å¤„ç†çƒ­åŠ›å›¾è¯·æ±‚
  const result = await controller.processHeatmapRequest(region, index, sector);
  
  // å‘é€ç»“æœåˆ°Telegram
  await sendTelegramResponse(message.chat.id, result);
}

// Telegramå“åº”æ ¼å¼åŒ–
async function sendTelegramResponse(chatId, result) {
  if (result.success) {
    // å‘é€å›¾ç‰‡
    await bot.sendPhoto(chatId, result.heatmapImage, {
      caption: result.report.title
    });
    
    // å‘é€è¯¦ç»†åˆ†æ
    const analysisText = formatReportForTelegram(result.report);
    await bot.sendMessage(chatId, analysisText, {
      parse_mode: 'HTML',
      disable_web_page_preview: true
    });
    
  } else {
    // å‘é€é”™è¯¯ä¿¡æ¯
    await bot.sendMessage(chatId, 
      `âŒ åˆ†æé‡åˆ°é—®é¢˜\n\n${result.report.executiveSummary}\n\né”™è¯¯: ${result.report.error}`,
      { parse_mode: 'HTML' }
    );
  }
}

function formatReportForTelegram(report) {
  return `
<b>${report.title}</b>

ğŸ“ˆ <b>å¸‚åœºæ¦‚è§ˆ</b>
${report.marketOverview.indexPerformance}
${report.marketOverview.marketBreadth}
${report.marketOverview.volume}

ğŸ” <b>æ¿å—åˆ†æ</b>
${report.sectorAnalysis.map(s => 
  `${s.name}: ${s.visualTrend === 'up' ? 'ğŸŸ¥' : 'ğŸŸ©'} ${s.visualChange}% ${s.consistency ? 'âœ…' : 'âš ï¸'}`
).join('\n')}

ğŸ’¡ <b>äº¤æ˜“æœºä¼š</b>
${report.tradingOpportunities?.join('\n') || 'éœ€è¿›ä¸€æ­¥åˆ†æ'}

âš ï¸ <b>é£é™©è¯„ä¼°</b>
ç­‰çº§: ${'â˜…'.repeat(report.riskAssessment)}${'â˜†'.repeat(5 - report.riskAssessment)}

ğŸ”® <b>å¸‚åœºå±•æœ›</b>
${report.outlook}

ğŸ“Š <b>æ•°æ®ç½®ä¿¡åº¦</b>
${report.dataConfidence}

<code>ç”Ÿæˆæ—¶é—´: ${new Date(report.timestamp).toLocaleString()}</code>
  `.trim();
}
6. ç¯å¢ƒå˜é‡é…ç½®
bash
# .env æ–‡ä»¶æ–°å¢é…ç½®
OPENAI_API_KEY=sk-proj-ä½ çš„OpenAIå¯†é’¥
FINNHUB_API_KEY=ä½ çš„Finnhubå¯†é’¥
FRED_API_KEY=ä½ çš„FREDå¯†é’¥
NEWS_API_KEY=ä½ çš„NewsAPIå¯†é’¥
N8N_WEBHOOK_URL=ä½ çš„n8næˆªå›¾æœåŠ¡Webhook

# å¯é€‰é…ç½®
ENABLE_VISION_ANALYSIS=true
DATA_RETRY_COUNT=3
REQUEST_TIMEOUT=30000
7. é¢„æœŸè¾“å‡ºç¤ºä¾‹
ç³»ç»Ÿç°åœ¨å°†ç”Ÿæˆè¿™æ ·çš„ä¸“ä¸šæŠ¥å‘Šï¼š

text
ğŸ“Š IBEX35 çƒ­åŠ›å›¾æ·±åº¦åˆ†ææŠ¥å‘Š

ã€æ‰§è¡Œæ‘˜è¦ã€‘
IBEX35æŒ‡æ•°ä¸Šæ¶¨0.8%ï¼Œæ±½è½¦æ¿å—é¢†æ¶¨+2.3%ï¼Œå¸‚åœºå¹¿åº¦å¥åº·ï¼Œä¸Šæ¶¨è‚¡ç¥¨å æ¯”65%ã€‚æŠ€æœ¯é¢æ˜¾ç¤ºçŸ­æœŸé˜»åŠ›ä½10,150ç‚¹ã€‚

ã€å¸‚åœºæ¦‚è§ˆã€‘
ğŸ”¹ IBEX35: 10,080.50 (+0.82%)
ğŸ”¹ å¸‚åœºå¹¿åº¦: ä¸Šæ¶¨21å®¶ / ä¸‹è·Œ11å®¶ / å¹³ç›˜3å®¶  
ğŸ”¹ æˆäº¤é‡: 4.2Bæ¬§å…ƒ
ğŸ”¹ æ³¢åŠ¨ç‡: 1.23%

ã€æ¿å—åˆ†æã€‘
ğŸŸ¥ æ±½è½¦: +2.3% (å®é™…+2.1%) âœ…
ğŸŸ¥ ç§‘æŠ€: +1.9% (å®é™…+1.8%) âœ…  
ğŸŸ© é‡‘è: -1.2% (å®é™…-1.3%) âœ…
ğŸŸ© èƒ½æº: -0.8% (å®é™…-0.9%) âœ…

ã€å…³é”®æ´å¯Ÿã€‘
â€¢ ITX.MCé¢†æ¶¨+3.4%ï¼Œå—å­£åº¦è´¢æŠ¥è¶…é¢„æœŸæ¨åŠ¨
â€¢ SAN.MCä¸‹è·Œ-2.1%ï¼Œå—æ¬§æ´²å¤®è¡Œæ”¿ç­–ä¸ç¡®å®šæ€§å½±å“
â€¢ æ±½è½¦æ¿å—èµ„é‡‘å‡€æµå…¥1.2äº¿æ¬§å…ƒ

ã€äº¤æ˜“æœºä¼šã€‘
1. å…³æ³¨æ±½è½¦æ¿å—è½®åŠ¨æœºä¼šï¼Œç›®æ ‡ä»·ä½+3-5%
2. è§„é¿åˆ©ç‡æ•æ„Ÿå‹é‡‘èè‚¡
3. ç§‘æŠ€æ¿å—çªç ´é˜»åŠ›åå¯åŠ ä»“

ã€é£é™©è¯„ä¼°ã€‘ â˜…â˜…â˜…â˜†â˜†
ä¸­ç­‰é£é™© - æ¬§æ´²æ”¿ç­–ä¸ç¡®å®šæ€§å­˜åœ¨

ã€æ•°æ®ç½®ä¿¡åº¦ã€‘ 92.5%
ç”Ÿæˆæ—¶é—´: 2024-01-15 14:30:25