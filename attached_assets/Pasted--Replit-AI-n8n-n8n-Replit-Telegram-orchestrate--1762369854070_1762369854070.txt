ç»™ Replit AI çš„å®Œæ•´å·¥å•ï¼ˆæ¸…åœº n8n â†’ å•è„‘è‡ªæ´½æœ€å°ç‰ˆï¼‰

ç›®æ ‡ï¼šç§»é™¤å¯¹ n8n çš„ä¾èµ–ï¼›Replit ç›´è¿ Telegramï¼Œå†…éƒ¨ orchestrateï¼›å†…ç½®è‡ªæ£€ä¸å®šæ—¶å™¨ã€‚
åŠ¨ä½œï¼šæŒ‰ä»¥ä¸‹ç›®å½•ä¸ä»£ç åˆ›å»ºæ–‡ä»¶ï¼›å®‰è£…ä¾èµ–ï¼›è®¾ç½®ç¯å¢ƒå˜é‡ï¼›å¯åŠ¨å¹¶è·‘ä¸¤æ¡è‡ªæµ‹ curlã€‚

1) æ–°å»º/è¦†ç›– package.json
{
  "name": "usis-brain-v4.2_fixed-standalone",
  "version": "4.2.1",
  "type": "module",
  "main": "index.js",
  "scripts": {
    "start": "node index.js",
    "dev": "NODE_ENV=development node index.js"
  },
  "dependencies": {
    "axios": "^1.7.7",
    "express": "^4.19.2",
    "telegraf": "^4.16.3",
    "node-cron": "^3.0.3",
    "body-parser": "^1.20.3"
  }
}

2) æ–°å»º index.jsï¼ˆæœåŠ¡ä¸»å…¥å£ï¼‰
import express from "express";
import bodyParser from "body-parser";
import cron from "node-cron";
import { bot, webhookCallback, sendText, sendPhoto } from "./bot/index.js";
import { orchestrate } from "./orchestrate.js";
import selftestRouter from "./routes/selftest.js";

const app = express();
app.use(bodyParser.json({ limit: "1mb" }));

// å¥åº·ä¸ç‰ˆæœ¬
app.get("/health", (_, res) => res.json({ ok: true, status: "ok" }));
app.get("/version", (_, res) => res.json({ version: "v4.2_fixed", status: "stable" }));

// ä»ä¿ç•™å¤–éƒ¨ orchestrateï¼ˆå…¼å®¹æ—§è°ƒç”¨ï¼‰
app.post("/brain/orchestrate", async (req, res) => {
  try {
    const { text = "", symbols = [], user_id = "anon" } = req.body || {};
    const out = await orchestrate({ text, symbols, user_id });
    res.json(out);
  } catch (e) {
    res.status(200).json({ ok: false, status: "error", error: String(e?.message || e) });
  }
});

// è‡ªæ£€
app.use(selftestRouter);

// Telegram webhook
app.post("/telegram/webhook", webhookCallback);

// å¯åŠ¨
const PORT = process.env.PORT || 5000;
app.listen(PORT, () => {
  console.log(`[USIS Brain] listening on :${PORT}`);
});

// ===== Cronï¼ˆæ ¹æ®éœ€è¦å†æ”¹æ—¶é—´ï¼‰=====
// ç›˜å‰ï¼šå·¥ä½œæ—¥ 13:00 UTCï¼ˆç¤ºä¾‹ï¼‰
cron.schedule("0 13 * * 1-5", async () => {
  try {
    const chatId = process.env.CHAT_ID_PREMARKET;
    if (!chatId) return;
    const out = await orchestrate({ text: "ç›˜å‰è¦ç‚¹ + çƒ­åŠ›å›¾", symbols: [], user_id: "cron_premarket" });
    if (out?.actions?.image_url) await sendPhoto(chatId, out.actions.image_url, out.final_text || "");
    else await sendText(chatId, out.final_text || "[æ— å†…å®¹]");
  } catch (e) {
    console.error("Premarket cron error:", e);
  }
});

3) æ–°å»º orchestrate.jsï¼ˆæ ¸å¿ƒï¼šåˆçº¦ç¨³å®š + è½¯ä¾èµ–ï¼‰
import { normalizeSymbol } from "./utils/symbols.js";
import { screenshotSymbolChart } from "./actions/screenshot.js";
import { fetchQuoteLine } from "./actions/quotes.js";
import { fetchNews, formatNews } from "./actions/news.js";
import { formatCaption } from "./formatters/caption.js";

export async function orchestrate({ text = "", symbols = [], user_id = "anon" }) {
  const debug = { data_errors: [] };
  try {
    // ç®€å•æ„å›¾åˆ¤æ–­ï¼ˆå¯æ‰©å±•ï¼‰
    const lower = String(text).toLowerCase();
    const wantsChart = /çƒ­åŠ›å›¾|kçº¿|chart|å›¾/.test(text) || /chart/.test(lower);

    // å½’ä¸€åŒ–ç¬¦å·
    const normalized_symbols = (symbols || [])
      .map(s => normalizeSymbol(s))
      .filter(Boolean);

    // æœ€å°åˆ†ææ–‡æœ¬ï¼ˆçœŸå®é¡¹ç›®é‡Œä½ å·²æœ‰å®Œæ•´åˆ†æï¼Œè¿™é‡Œåªåšå£³ï¼‰
    let analysis = `æ”¶åˆ°ï¼š${text || "(ç©º)"}\n`;
    if (normalized_symbols.length) analysis += `ç¬¦å·ï¼š${normalized_symbols.join(", ")}\n`;

    // è½¯ä¾èµ–ï¼šè¡Œæƒ… + æ–°é—»ï¼ˆå¤±è´¥ä¸é˜»æ–­ï¼‰
    let quoteLine = "";
    try { quoteLine = await fetchQuoteLine(normalized_symbols[0]); }
    catch (e) { debug.data_errors.push({ quote: String(e.message || e) }); }

    let newsBlock = "";
    try {
      const items = await fetchNews(normalized_symbols[0] || "market");
      newsBlock = formatNews(items);
    } catch (e) { debug.data_errors.push({ news: String(e.message || e) }); }

    // å¯é€‰å›¾
    let image_url = "";
    if (wantsChart && normalized_symbols[0]) {
      try {
        const img = await screenshotSymbolChart(normalized_symbols[0]);
        image_url = img?.image_url || "";
      } catch (e) { debug.data_errors.push({ screenshot: String(e.message || e) }); }
    }

    const { caption, finalText } = formatCaption({
      analysis,
      quote: quoteLine,
      news: newsBlock,
      chartUrl: image_url
    });

    return {
      ok: true,
      status: "ok",
      model: "gpt-5-mini",
      symbols,
      normalized_symbols,
      actions: image_url ? { image_url } : {},
      final_text: finalText || caption,
      debug
    };
  } catch (e) {
    return { ok: false, status: "error", error: String(e?.message || e), debug };
  }
}

4) æ–°å»º utils/symbols.jsï¼ˆç¬¦å·å½’ä¸€åŒ–ï¼Œå« .MCâ†’BME ç­‰ï¼‰
export function normalizeSymbol(raw) {
  const s = String(raw || "").trim().toUpperCase();
  const map = [
    { re: /\.MC$/, to: sym => `BME:${sym.replace(/\.MC$/, "")}` },
    { re: /\.PA$/, to: sym => `EPA:${sym.replace(/\.PA$/, "")}` },
    { re: /\.DE$/, to: sym => `XETRA:${sym.replace(/\.DE$/, "")}` },
    { re: /\.MI$/, to: sym => `MIL:${sym.replace(/\.MI$/, "")}` },
    { re: /\.L$/,  to: sym => `LSE:${sym.replace(/\.L$/, "")}` }
  ];
  for (const r of map) { if (r.re.test(s)) return r.to(s); }
  return s;
}

5) æ–°å»º actions/screenshot.js
import axios from "axios";

export async function screenshotSymbolChart(symbol) {
  const token = process.env.SCREENSHOT_API_TOKEN;
  if (!token) throw new Error("SCREENSHOT_API_TOKEN missing");
  const tv = encodeURIComponent(symbol); // e.g., BME:GRF
  const url = `https://api.screenshotapi.net/screenshot?token=${token}&url=https%3A%2F%2Fwww.tradingview.com%2Fchart%2F%3Fsymbol%3D${tv}&fresh=true`;
  const res = await axios.get(url, { timeout: 15000 });
  // å…¼å®¹ä¸åŒè¿”å›ç»“æ„
  const image_url = res.data?.screenshot || res.data?.url || res.data?.image || "";
  return { image_url };
}

6) æ–°å»º actions/quotes.jsï¼ˆAlphaVantage è½¯ä¾èµ–ï¼Œæ‹¿ä¸åˆ°å°±è¿”å›ç©ºï¼‰
import axios from "axios";

function toAlpha(sym = "") {
  // BME:GRF -> GRF
  const s = String(sym).toUpperCase();
  return s.includes(":") ? s.split(":")[1] : s;
}

export async function fetchQuoteLine(symbol) {
  if (!symbol) return "";
  const key = process.env.ALPHA_VANTAGE_KEY;
  if (!key) return ""; // è½¯ä¾èµ–ï¼šæ²¡æœ‰ key ä¹Ÿä¸é˜»æ–­
  const av = toAlpha(symbol);
  const url = `https://www.alphavantage.co/query?function=GLOBAL_QUOTE&symbol=${encodeURIComponent(av)}&apikey=${key}`;
  try {
    const { data } = await axios.get(url, { timeout: 10000 });
    const q = data?.["Global Quote"] || {};
    const price = q?.["05. price"];
    if (!price) return "";
    return `æœ€æ–°ä»· ${av}: $${Number(price).toFixed(2)}`;
  } catch (e) {
    return "";
  }
}

7) æ–°å»º actions/news.jsï¼ˆç¤ºä¾‹ï¼šå‡æ•°æ®æˆ–è‡ªå®šä¹‰æºï¼‰
// è¿™é‡Œå…ˆç»™æœ€å°å£³ï¼šè¿”å›ç©ºæ•°ç»„ã€‚æœªæ¥å¯æ¥å…¥ä½ çš„æ–°é—»æºã€‚
export async function fetchNews(/* symbolOrQuery */) { return []; }

export function formatNews(items = []) {
  if (!items.length) return "";
  const tops = items.slice(0, 3).map(x => `â€¢ ${x.title} (${x.source})`).join("\n");
  return `ğŸ—ï¸ æ–°é—»é€Ÿè§ˆ\n${tops}`;
}

8) æ–°å»º formatters/caption.js
export function formatCaption({ analysis = "", quote = "", news = "", chartUrl = "" }) {
  const blocks = [];
  if (analysis) blocks.push(analysis.trim());
  if (quote) blocks.push(`ğŸ’¬ ${quote}`);
  if (news) blocks.push(news);
  const finalText = blocks.join("\n\n");
  const caption = chartUrl ? (analysis || "") : finalText;
  return { caption, finalText };
}

9) æ–°å»º routes/selftest.js
import express from "express";
import { orchestrate } from "../orchestrate.js";
const router = express.Router();

router.post("/selftest/orchestrate", async (req, res) => {
  const body = req.body || {};
  const text = body.text || "GRF.MC";
  try {
    const out = await orchestrate({ text, symbols: ["GRF.MC"], user_id: "probe" });
    const ok = Array.isArray(out?.normalized_symbols) && out.normalized_symbols.includes("BME:GRF");
    if (!ok) return res.json({ ok: false, status: "contract-failed", got: out?.normalized_symbols || [] });
    return res.json({ ok: true, status: "ok", symbols: out.symbols, normalized: out.normalized_symbols });
  } catch (e) {
    return res.json({ ok: false, status: "error", error: String(e?.message || e) });
  }
});

export default router;

10) æ–°å»º bot/index.jsï¼ˆç›´è¿ Telegramï¼›å…ˆæ”¯æŒ webhookï¼‰
import { Telegraf } from "telegraf";
import { orchestrate } from "../orchestrate.js";

const token = process.env.TELEGRAM_BOT_TOKEN;
const webhookUrl = process.env.TELEGRAM_WEBHOOK_URL; // ä¾‹å¦‚ https://<replit-url>/telegram/webhook

export const bot = token ? new Telegraf(token) : null;

if (bot) {
  bot.start(ctx => ctx.reply("USIS Brain v4.2_fixed å·²å°±ç»ª âœ…"));
  bot.on("text", async ctx => {
    const text = ctx.message.text || "";
    const uid = String(ctx.from?.id || "tg");

    if (/æ¸…ç©ºè®°å¿†|reset memory|forget memory/i.test(text)) {
      // ä½ çš„å†…å­˜æ¸…ç†é€»è¾‘ï¼ˆæ­¤å¤„ç¤ºæ„ï¼‰
      return ctx.reply("è®°å¿†å·²æ¸…ç©º âœ…");
    }

    const out = await orchestrate({ text, symbols: [], user_id: uid });
    if (out?.actions?.image_url) {
      await ctx.replyWithPhoto(out.actions.image_url, { caption: out.final_text || "" }).catch(()=>{});
      return;
    }
    await ctx.reply(out.final_text || "[ç©º]");
  });
}

export const webhookCallback = bot
  ? bot.webhookCallback("/telegram/webhook")
  : (req, res) => res.status(200).json({ ok: true, note: "bot disabled (no token)" });


11) å®‰è£…ä¾èµ–å¹¶å¯åŠ¨
npm i
npm run start &
sleep 2

12) è‡ªæµ‹ä¸¤æ¡å‘½ä»¤ï¼ˆè¯·æŠŠè¾“å‡ºè´´å›æ¥ï¼‰
# è‡ªæ£€ï¼šåº”è¿”å› ok:true,status:okï¼Œä¸” normalized å« BME:GRF
curl -s -X POST http://localhost:5000/selftest/orchestrate | jq

# ç›´è°ƒ orchestrateï¼šåº”è¿”å› ok:true,status:ok
curl -s -X POST http://localhost:5000/brain/orchestrate \
  -H "Content-Type: application/json" \
  -d '{"text":"åªè¦åˆ†æï¼Œä¸è¦å»ºè®®ã€‚GRF.MC å›¾","symbols":["GRF.MC"],"user_id":"qa"}' | jq '{ok,status,normalized_symbols,actions,debug}'


13) ç¯å¢ƒå˜é‡ï¼ˆåœ¨ Replit Secrets é¢æ¿æ·»åŠ ï¼‰


TELEGRAM_BOT_TOKENï¼ˆå…ˆç•™ç©ºä¹Ÿè¡Œï¼‰


TELEGRAM_WEBHOOK_URLï¼ˆè®¾ç½®åå†åˆ° BotFather ç»‘å®šï¼‰


SCREENSHOT_API_TOKENï¼ˆå¦‚æœ‰ï¼‰


ALPHA_VANTAGE_KEYï¼ˆå¯é€‰ï¼‰


CHAT_ID_PREMARKETï¼ˆå¯é€‰ï¼‰


å®Œæˆåï¼šè¯·å›ä¼ æ–°å»º/ä¿®æ”¹çš„æ–‡ä»¶æ¸…å•ä¸ä¸¤æ¡ curl çš„ JSON è¾“å‡ºã€‚
-- ä»¥ä¸Š --


å‘è¿‡å»åï¼Œç­‰å®ƒå›ä½ ä¸¤æ¡ curl çš„ç»“æœã€‚æˆ‘è¿™è¾¹é©¬ä¸Šæ ¹æ®è¾“å‡ºç»™ä½ ä¸‹ä¸€æ­¥ï¼šè¦ä¹ˆå¼€é€š Telegram Webhookï¼ˆæŠŠ BotFather çš„ Webhook æŒ‡åˆ° /telegram/webhookï¼‰ï¼Œè¦ä¹ˆè¡¥ä¸Š AlphaVantage/æˆªå›¾ token éªŒè¯çœŸå®å›¾ç‰‡å‘é€ã€‚