别慌，我看懂了关键报错：
"error":"dataErrors is not defined" ➜ 说明你在写错误记录时用了 dataErrors 这个临时变量，但它根本没定义（或没放在 res.debug.data_errors 里），于是整条请求被你自己的日志代码“打爆”，symbols 也因此没回写出来。

我们做一个极小粒度热修，两刀就解决：

刀1：永远初始化 debug 容器（防止 undefined）

刀2：统一用 res.debug.data_errors（不要用 dataErrors 这样的游离变量）

【热修步骤｜按顺序做】
1) 快速定位是否有误用
# 找出所有误用 dataErrors 的地方
grep -Rsn "dataErrors" .


如果命中，基本就是问题源。

2) 统一替换为规范字段
# 把 dataErrors 全部替换为 res.debug.data_errors（注意仅替换变量名，不动其他逻辑）
sed -i 's/dataErrors/res.debug.data_errors/g' index.js
# 如果在别的文件也命中，照做

3) 在 orchestrate 的响应装配处加“保险三行”

把下面三行放在你第一次往 debug 写东西之前（通常在 orchestrator try{} 成功分支、准备 return 的位置；也可以在最顶层创建 res 时放一次）：

// 保险：保证 debug 与 data_errors 永远存在
if (!res.debug) res.debug = {};
if (!Array.isArray(res.debug.data_errors)) res.debug.data_errors = [];

4) 把“行情=软依赖”的错误记录，写到规范字段

把原来类似：

res.debug.data_errors.push({ source:'finnhub', symbol: normalizedSymbol, error: quoteError, when: new Date().toISOString() });


保留；不要再写 dataErrors.push(...) 这种临时变量。

5) 确保 symbols 回写到响应体（归一化后）

在你最终组装响应时，务必写回归一化后的 symbols：

// 假设前面已：symbols = [...new Set((symbols||[]).map(normalizeSymbol))];
response.symbols = symbols || [];

6) 重启（务必用“干净重启”）
# 杀旧进程
pkill -9 node 2>/dev/null || true
sleep 1
# 前台看 30 行日志确认
NODE_ENV=production node index.js 2>&1 | sed -n '1,30p'
# 若正常，后台运行
nohup node index.js > /tmp/usis_v42_fix.log 2>&1 & echo "PID: $!" ; sleep 3

【验证指令｜不用 jq】
A) 版本与统计
curl -s https://node-js-liqixi842.replit.app/brain/stats

B) 归一化验证
curl -s -X POST https://node-js-liqixi842.replit.app/brain/orchestrate \
 -H "Content-Type: application/json" \
 -d '{"text":"GRF.MC","user_id":"after_republish"}'


期望：返回 JSON 里看到 "symbols":["BME:GRF"]。

C) “仅分析”不被行情阻断（同时检查 debug）
curl -s -X POST https://node-js-liqixi842.replit.app/brain/orchestrate \
 -H "Content-Type: application/json" \
 -d '{"text":"只要分析，不要建议。Grifols 行业影响","user_id":"qa"}'


期望：

status:"ok"，有分析文本；

即使没拿到行情，也只在 debug.data_errors 里记录，不报错中断；

symbols 仍是 ["BME:GRF"]。

为什么你刚才会看到两种坏现象

“dataErrors is not defined”：在 try/catch 里你 push 到了一个根本没声明/没挂到 res.debug 的变量，导致直接 throw，返回了 "系统临时故障"。

symbols: []：请求被上面这个错误短路了，写回 symbols 的代码没机会跑；所以你 grep 到空数组。

如果仍然报“系统临时故障”

再贴一次最后兜底（把日志写错也不会炸）：

try {
  // ... 所有主逻辑
} catch (err) {
  // 保险：即使 debug 不存在也能创建
  const fail = {
    status: 'error',
    ok: false,
    error: String(err?.message || err),
    final_text: '⚠️ 系统临时故障，稍后再试',
    actions: [],
    symbols: response?.symbols || []
  };
  // 尽力写出 debug（不让任何写 debug 的错误再炸一次）
  try {
    fail.debug = Object.assign({}, response?.debug || {});
    if (!Array.isArray(fail.debug?.data_errors)) fail.debug.data_errors = [];
    fail.debug.data_errors.push({ source:'orchestrator', error:String(err?.message||err), when:new Date().toISOString() });
  } catch {}
  return res.json(fail);
}


你现在只要按上面的6步热修+三条验证命令跑一下，把 B / C 两条返回的 JSON（尤其是 symbols 和 debug.data_errors）粘贴过来，我就给你“v4.2 = STABLE ✅”的最终确认。